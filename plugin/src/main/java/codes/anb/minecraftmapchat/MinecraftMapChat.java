/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package codes.anb.minecraftmapchat;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Scanner;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.logging.Level;

import org.bukkit.Bukkit;
import org.bukkit.command.CommandSender;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerJoinEvent;
import org.bukkit.event.player.PlayerMoveEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.plugin.java.JavaPlugin;

import io.papermc.paper.event.player.AsyncChatEvent;
import net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;

public class MinecraftMapChat extends JavaPlugin implements Listener {
    Process serverProcess;
    Thread outThread;
    BlockingQueue<String> inputQueue = new LinkedBlockingQueue<>();
    BlockingQueue<String> chatQuene = new LinkedBlockingQueue<>();

    @Override
    public void onDisable() {
        serverProcess.destroy();
    }

    @Override
    public void onEnable() {
        Bukkit.getPluginManager().registerEvents(this, this);

        var execName = OSUtil.getOS() == OSUtil.OS.WINDOWS ? "server-win.exe"
                : OSUtil.getOS() == OSUtil.OS.MAC ? "server-macos"
                        : OSUtil.getOS() == OSUtil.OS.LINUX ? "server-linux"
                                : null;
        if (execName == null) {
            throw new RuntimeException("OS not supported");
        }

        saveDefaultConfig();

        this.saveResource(execName, true);
        this.saveResource("client.zip", true);
        this.saveResource("image-generator", true);

        var dataFolder = this.getDataFolder().toPath();
        var path = dataFolder.resolve(execName);
        var tiles = dataFolder;
        var worldFolder = this.getServer().getWorlds().get(0).getWorldFolder();
        var input = worldFolder.toPath().resolve("region");

        path.toFile().setExecutable(true);
        var pathImageGenerator = dataFolder.resolve("image-generator");
        pathImageGenerator.toFile().setExecutable(true);

        var port = getConfig().get("port").toString();
        var host = getConfig().get("host").toString();

        try {
            var builder = new ProcessBuilder(
                    path.toAbsolutePath().toString(),
                    input.toAbsolutePath().toString(),
                    tiles.toAbsolutePath().toString(),
                    host,
                    port);

            serverProcess = builder.start();

            Bukkit.getScheduler().runTaskAsynchronously(this, () -> {
                Scanner scanner = new Scanner(serverProcess.getInputStream());
                while (scanner.hasNextLine()) {
                    try {
                        inputQueue.put(scanner.nextLine());
                    } catch (InterruptedException e) {
                        this.getLogger().log(Level.SEVERE, e.getMessage());
                    }
                }
            });
        } catch (IOException e) {
            Bukkit.getConsoleSender().sendMessage("Failed to start map server: " + e.getMessage());
        }

        // Handle events from the js app
        Bukkit.getScheduler().scheduleSyncRepeatingTask(this, () -> {
            var w = new PrintWriter(serverProcess.getOutputStream());
            while (!chatQuene.isEmpty()) {
                var chat = chatQuene.poll();
                w.println(chat);
            }

            while (!inputQueue.isEmpty()) {
                var event = inputQueue.poll();
                if (event == null) {
                    continue;
                }

                var parts = event.split(" ");

                if (parts[0].equals("exec")) {
                    var command = String.join(" ", Arrays.copyOfRange(parts, 1, parts.length));

                    this.getServer().dispatchCommand(this.getServer().getConsoleSender(), command);
                } else if (parts[0].equals("execas")) {

                    var player = this.getServer().getPlayer(parts[1]);
                    var command = String.join(" ", Arrays.copyOfRange(parts, 2, parts.length));

                    CommandSender executor = player;
                    if (player == null) {
                        w.print("error invalid player");
                        continue;
                    }

                    this.getServer().dispatchCommand(executor, command);
                } else if (parts[0].equals("chat")) {

                    var player = parts[1];
                    var message = String.join(" ", Arrays.copyOfRange(parts, 2, parts.length));

                    this.getServer().getOnlinePlayers().forEach((p) -> p.sendMessage("[" + player + "] " + message));
                } else if (parts[0].equals("log")) {

                    var message = String.join(" ", Arrays.copyOfRange(parts, 1, parts.length));

                    this.getServer().getLogger().log(Level.INFO, message);
                }
            }

            w.flush();
        }, 1, 1);
    }

    @EventHandler
    public void onPlayerJoin(PlayerJoinEvent event) {
        var w = new PrintWriter(serverProcess.getOutputStream());
        w.println("join " + event.getPlayer().getName());

        w.flush();
    }

    @EventHandler
    public void onPlayerLeave(PlayerQuitEvent event) {
        var w = new PrintWriter(serverProcess.getOutputStream());
        w.println("leave " + event.getPlayer().getName());

        w.flush();
    }

    @EventHandler
    public void onPlayerMove(PlayerMoveEvent event) {
        var w = new PrintWriter(serverProcess.getOutputStream());
        var player = event.getPlayer();
        var x = player.getX();
        var y = player.getY();
        var z = player.getZ();
        var yaw = player.getYaw();
        var pitch = player.getPitch();
        w.println("m " + player.getName() + " " + x + " " + y + " " + z + " " + yaw + " " + pitch);
        w.flush();
    }

    @EventHandler
    public void onAsyncChatEvent(AsyncChatEvent event) {
        var player = event.getPlayer();
        var message = event.message();
        var json = GsonComponentSerializer.gson().serialize(message);
        try {
            chatQuene.put("chat " + player.getName() + " " + json);
        } catch (InterruptedException e) {
            this.getLogger().log(Level.SEVERE, e.getMessage());
        }
    }
}